<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>高级篇（四）Redis 原理篇（二）网络模型 - 黄波的博客</title><meta name=author content="黄波"><meta name=author-link content="https://dilless.github.io"><meta name=description content="1. Linux IO 模型 1.1 用户空间和内核空间 内核本身上来说也是一个应用，所以他本身也需要一些内存，cpu等设备资源，用户应用本身也在消耗这些资源，如果不加"><meta name=keywords content="redis,数据库,缓存,实现原理,网络模型"><meta itemprop=name content="高级篇（四）Redis 原理篇（二）网络模型"><meta itemprop=description content="1. Linux IO 模型 1.1 用户空间和内核空间 内核本身上来说也是一个应用，所以他本身也需要一些内存，cpu等设备资源，用户应用本身也在消耗这些资源，如果不加"><meta itemprop=datePublished content="2022-08-06T00:00:00+08:00"><meta itemprop=dateModified content="2022-08-07T14:00:00+08:00"><meta itemprop=wordCount content="3100"><meta itemprop=image content="https://dilless.github.io/logo.png"><meta itemprop=keywords content="redis,数据库,缓存,实现原理,网络模型,"><meta property="og:title" content="高级篇（四）Redis 原理篇（二）网络模型"><meta property="og:description" content="1. Linux IO 模型 1.1 用户空间和内核空间 内核本身上来说也是一个应用，所以他本身也需要一些内存，cpu等设备资源，用户应用本身也在消耗这些资源，如果不加"><meta property="og:type" content="article"><meta property="og:url" content="https://dilless.github.io/posts/notes/databases/redis/itheima_redis_lesson/advanced/4-redis-principle-2-network/"><meta property="og:image" content="https://dilless.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-06T00:00:00+08:00"><meta property="article:modified_time" content="2022-08-07T14:00:00+08:00"><meta property="og:site_name" content="黄波的博客"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dilless.github.io/logo.png"><meta name=twitter:title content="高级篇（四）Redis 原理篇（二）网络模型"><meta name=twitter:description content="1. Linux IO 模型 1.1 用户空间和内核空间 内核本身上来说也是一个应用，所以他本身也需要一些内存，cpu等设备资源，用户应用本身也在消耗这些资源，如果不加"><meta name=application-name content="黄波的博客"><meta name=apple-mobile-web-app-title content="黄波的博客"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#252627"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://dilless.github.io/posts/notes/databases/redis/itheima_redis_lesson/advanced/4-redis-principle-2-network/><link rel=prev href=https://dilless.github.io/posts/notes/databases/redis/itheima_redis_lesson/advanced/3-redis-principle-1-data-structure/><link rel=next href=https://dilless.github.io/posts/notes/databases/redis/itheima_redis_lesson/advanced/5-redis-principle-3-resp-protocol/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><meta name=google-site-verification content="3_Zf27e0mNtTIsBWn36hi_d4KTxPd2Zh1dsZMVnKK8k"><meta name=baidu-site-verification content="code-VsfDko5mls"><meta name=360-site-verification content="1a8490494ad7f3fe3e0f7e4a61ce0775"><meta name=sogou_site_verification content="OTqUhL8vdL"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"高级篇（四）Redis 原理篇（二）网络模型","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/dilless.github.io\/posts\/notes\/databases\/redis\/itheima_redis_lesson\/advanced\/4-redis-principle-2-network\/"},"genre":"posts","keywords":"redis, 数据库, 缓存, 实现原理, 网络模型","wordcount":3100,"url":"https:\/\/dilless.github.io\/posts\/notes\/databases\/redis\/itheima_redis_lesson\/advanced\/4-redis-principle-2-network\/","datePublished":"2022-08-06T00:00:00+08:00","dateModified":"2022-08-07T14:00:00+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"黄波"},"description":""}</script></head><body header-desktop=sticky header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper github-corner=right><div class=header-title><a href=/ title=黄波的博客><img class="lazyload logo" src=/svg/loading.min.svg data-src=/apple-touch-icon.png data-srcset="/apple-touch-icon.png, /apple-touch-icon.png 1.5x, /apple-touch-icon.png 2x" data-sizes=auto alt=黄波的博客 title=黄波的博客><span class=header-title-text>黄波的博客</span></a><span class=header-subtitle>开发、学习、生活、技术分享</span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/><i class='fa-solid fa-archive fa-fw fa-sm'></i> 文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class='fa-solid fa-th fa-fw fa-sm'></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class='fa-solid fa-tags fa-fw fa-sm'></i> 标签</a></li><li class=menu-item><a class=menu-link href=/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><i class='fa-solid fa-book fa-fw fa-sm'></i> 学习笔记</a></li><li class=menu-item><a class=menu-link href=/about/><i class='fa-solid fa-info-circle fa-fw fa-sm'></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item language"><span title=选择语言>简体中文<i class="dropdown-icon fa-solid fa-chevron-down"></i></span><ul class=sub-menu><li class=menu-item>没有更多翻译</li></ul></li><li class="menu-item search" id=search-desktop><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li></ul></nav></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=黄波的博客><img class="lazyload logo" src=/svg/loading.min.svg data-src=/apple-touch-icon.png data-srcset="/apple-touch-icon.png, /apple-touch-icon.png 1.5x, /apple-touch-icon.png 2x" data-sizes=auto alt=/apple-touch-icon.png title=/apple-touch-icon.png><span class=header-title-text>黄波的博客</span></a><span class=header-subtitle>开发、学习、生活、技术分享</span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/posts/><i class='fa-solid fa-archive fa-fw fa-sm'></i> 文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class='fa-solid fa-th fa-fw fa-sm'></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class='fa-solid fa-tags fa-fw fa-sm'></i> 标签</a></li><li class=menu-item><a class=menu-link href=/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><i class='fa-solid fa-book fa-fw fa-sm'></i> 学习笔记</a></li><li class=menu-item><a class=menu-link href=/about/><i class='fa-solid fa-info-circle fa-fw fa-sm'></i> 关于</a></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li><li class="menu-item language"><span title=选择语言>简体中文<i class="dropdown-icon fa-solid fa-chevron-down"></i></span>
<select class=language-select onchange="location=this.value"><option disabled>没有更多翻译</option></select></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container page-style=normal><aside class=toc id=toc-auto><h2 class=toc-title>目录 <i class="toc-icon fa-solid fa-angle-down fa-fw"></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>高级篇（四）Redis 原理篇（二）网络模型</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://dilless.github.io title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><i class="fa-solid fa-user-circle"></i>
黄波</a></span>
<span class=post-category>收录于 <a href=/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><i class="fa-regular fa-folder fa-fw"></i>&nbsp;学习笔记</a>&ensp;<a href=/categories/redis/><i class="fa-regular fa-folder fa-fw"></i>&nbsp;redis</a></span></div><div class=post-meta-line><span title="2022-08-06 00:00:00"><i class="fa-regular fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-08-06>2022-08-06</time>
</span>&nbsp;<i class="fa-solid fa-pencil-alt fa-fw"></i>&nbsp;约 3100 字&nbsp;
<i class="fa-regular fa-clock fa-fw"></i>&nbsp;预计阅读 7 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-linux-io-模型>1. Linux IO 模型</a><ul><li><a href=#11-用户空间和内核空间>1.1 用户空间和内核空间</a></li><li><a href=#12-五种-io-模型>1.2 五种 IO 模型</a><ul><li><a href=#121-阻塞-io>1.2.1 阻塞 IO</a></li><li><a href=#122-非阻塞-io>1.2.2 非阻塞 IO</a></li><li><a href=#123-io-多路复用>1.2.3 IO 多路复用</a><ul><li><a href=#1231-select-模式>1.2.3.1 select 模式</a></li><li><a href=#1232-poll-模式>1.2.3.2 poll 模式</a></li><li><a href=#1233-epoll-模式>1.2.3.3 epoll 模式</a></li><li><a href=#1234-三种模式总结>1.2.3.4 三种模式总结</a></li><li><a href=#1235-事件通知机制>1.2.3.5 事件通知机制</a></li><li><a href=#1236-基于-epoll-的-web-服务的基本流程>1.2.3.6 基于 epoll 的 web 服务的基本流程</a></li></ul></li><li><a href=#124-信号驱动-io>1.2.4 信号驱动 IO</a></li><li><a href=#125-异步-io>1.2.5 异步 IO</a></li><li><a href=#126-五种-io-模型对比>1.2.6 五种 IO 模型对比</a></li></ul></li></ul></li><li><a href=#2-redis-网络模型>2. Redis 网络模型</a><ul><li><a href=#21-redis是单线程的吗为什么使用单线程>2.1 Redis是单线程的吗？为什么使用单线程</a></li><li><a href=#22-单线程和多线程模型>2.2 单线程和多线程模型</a></li></ul></li></ul></nav></div></div><div class=content id=content><h2 id=1-linux-io-模型>1. Linux IO 模型</h2><h3 id=11-用户空间和内核空间>1.1 用户空间和内核空间</h3><p>内核本身上来说也是一个应用，所以他本身也需要一些内存，cpu等设备资源，用户应用本身也在消耗这些资源，如果不加任何限制，用户去操作随意的去操作我们的资源，就有可能导致一些冲突，甚至有可能导致我们的系统出现无法运行的问题，因此我们需要把用户和<strong>内核隔离开</strong></p><p>进程的寻址空间划分成两部分：<strong>内核空间、用户空间</strong></p><p>什么是寻址空间呢？我们的应用程序也好，还是内核空间也好，都是没有办法直接去物理内存的，而是通过分配一些虚拟内存映射到物理内存中，我们的内核和应用程序去访问虚拟内存的时候，就需要一个虚拟地址，这个地址是一个无符号的整数，比如一个32位的操作系统，他的带宽就是32，他的虚拟地址就是2的32次方，也就是说他寻址的范围就是0~2的32次方， 这片寻址空间对应的就是2的32个字节，就是4GB，这个4GB，会有3个GB分给用户空间，会有1GB给内核系统</p><p>在linux中，权限分成两个等级，0和3，用户空间只能执行受限的命令（Ring3），而且不能直接调用系统资源，必须通过内核提供的接口来访问内核空间可以执行特权命令（Ring0），调用一切系统资源，所以一般情况下，用户的操作是运行在用户空间，而内核运行的数据是在内核空间的，而有的情况下，<strong>一个应用程序需要去调用一些特权资源</strong>，去调用一些内核空间的操作，所以此时他俩需要在用户态和内核态之间进行切换。</p><p>Linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区：</p><ul><li>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</li><li>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</li></ul><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/1653896687354.png data-srcset="../images/1653896687354.png, ../images/1653896687354.png 1.5x, ../images/1653896687354.png 2x" data-sizes=auto alt=../images/1653896687354.png title=用户空间和内核空间></p><h3 id=12-五种-io-模型>1.2 五种 IO 模型</h3><p>在《UNIX网络编程》一书中，总结归纳了5种IO模型：</p><ul><li>阻塞IO（Blocking IO）</li><li>非阻塞IO（Nonblocking IO）</li><li>IO多路复用（IO Multiplexing）</li><li>信号驱动IO（Signal Driven IO）</li><li>异步IO（Asynchronous IO）</li></ul><blockquote><p>应用程序想要去读取数据，他是无法直接去读取磁盘、网卡等的，有两个等待阶段：</p><ol><li>先到内核里边去等待内核操作硬件拿到数据</li><li>再把这个数据写给用户的缓存区</li></ol></blockquote><h4 id=121-阻塞-io>1.2.1 阻塞 IO</h4><p>用户去读取数据时，会去先发起 recvform 一个命令，去尝试从内核上加载数据，如果内核没有数据，那么用户就会等待，此时内核会去从硬件上读取数据，内核读取数据之后，会把数据拷贝到用户态，并且返回ok，整个过程，都是阻塞等待的，这就是阻塞IO。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/1653897270074.png data-srcset="../images/1653897270074.png, ../images/1653897270074.png 1.5x, ../images/1653897270074.png 2x" data-sizes=auto alt=../images/1653897270074.png title="阻塞 IO"></p><blockquote><p>阻塞IO模型中，用户进程在两个阶段都是阻塞状态。</p></blockquote><h4 id=122-非阻塞-io>1.2.2 非阻塞 IO</h4><p>非阻塞IO的recvfrom操作会立即返回结果而不是阻塞用户进程。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/1653897490116.png data-srcset="../images/1653897490116.png, ../images/1653897490116.png 1.5x, ../images/1653897490116.png 2x" data-sizes=auto alt=../images/1653897490116.png title="非阻塞 IO"></p><blockquote><p>非阻塞IO模型中，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增。</p></blockquote><h4 id=123-io-多路复用>1.2.3 IO 多路复用</h4><p>用户进程如何知道内核中数据是否就绪呢？</p><p>文件描述符（File Descriptor）：简称FD，是一个从0 开始的无符号整数，用来关联Linux中的一个文件。在Linux中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字（Socket）。</p><p>IO 多路复用：利用一个线程监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/1653898691736.png data-srcset="../images/1653898691736.png, ../images/1653898691736.png 1.5x, ../images/1653898691736.png 2x" data-sizes=auto alt=../images/1653898691736.png title="IO 多路复用"></p><p>监听FD的方式、通知的方式又有多种实现，常见的有：</p><ul><li>select</li><li>poll</li><li>epoll</li></ul><blockquote><p>elect 和 pool 相当于是当被监听的数据准备好之后，他会把你监听的所有FD整个数据都发给你，你需要到所有FD中去找，哪些是处理好了的，需要通过遍历的方式，所以性能也并不是那么好。</p><p>epoll，则相当于内核准备好了之后，他会把准备好的数据，直接发给你，咱们就省去了遍历的动作。</p></blockquote><h5 id=1231-select-模式>1.2.3.1 select 模式</h5><p>select是Linux最早的I/O多路复用实现方案。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/20220806210444.png data-srcset="../images/20220806210444.png, ../images/20220806210444.png 1.5x, ../images/20220806210444.png 2x" data-sizes=auto alt=../images/20220806210444.png title="select 模式"></p><p>select 模式存在的问题：</p><ul><li>需要将整个fd_set从用户空间拷贝到内核空间，select结束还要再次拷贝回用户空间</li><li>select无法得知具体是哪个fd就绪，需要遍历整个fd_set</li><li>fd_set监听的fd数量不能超过1024，对高并发来讲完全不够用</li></ul><h5 id=1232-poll-模式>1.2.3.2 poll 模式</h5><p>poll 模式对 select 模式做了简单改进，但性能提升不明显。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/1653900721427.png data-srcset="../images/1653900721427.png, ../images/1653900721427.png 1.5x, ../images/1653900721427.png 2x" data-sizes=auto alt=../images/1653900721427.png title="poll 模式"></p><p>与select对比：</p><ul><li>select模式中的fd_set大小固定为1024，而pollfd在内核中采用数组，理论上无上限</li><li>监听FD越多，每次遍历消耗时间也越久，性能反而会下降</li></ul><h5 id=1233-epoll-模式>1.2.3.3 epoll 模式</h5><p>epoll 模式是对 select 和 poll 的巨大改进。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/20220806212510.png data-srcset="../images/20220806212510.png, ../images/20220806212510.png 1.5x, ../images/20220806212510.png 2x" data-sizes=auto alt=../images/20220806212510.png title="epoll 模式"></p><h5 id=1234-三种模式总结>1.2.3.4 三种模式总结</h5><p>select模式存在的三个问题：</p><ul><li>能监听的FD最大不超过1024</li><li>每次select都需要把所有要监听的FD都拷贝到内核空间</li><li>每次都要遍历所有FD来判断就绪状态</li></ul><p>poll模式的问题：</p><ul><li>poll利用链表解决了select中监听FD上限的问题，但依然要遍历所有FD，如果监听较多，性能会下降</li></ul><p>epoll模式中如何解决这些问题的？</p><ul><li>基于epoll实例中的红黑树保存要监听的FD，理论上无上限，而且增删改查效率都非常高</li><li>每个FD只需要执行一次epoll_ctl添加到红黑树，以后每次epol_wait无需传递任何参数，无需重复拷贝FD到内核空间</li><li>利用ep_poll_callback机制来监听FD状态，无需遍历所有FD，因此性能不会随监听的FD数量增多而下降</li></ul><h5 id=1235-事件通知机制>1.2.3.5 事件通知机制</h5><p>当FD有数据可读时，我们调用epoll_wait（或者select、poll）可以得到通知。但是事件通知的模式有两种：</p><ul><li>LevelTriggered：简称LT，也叫做水平触发。只要某个FD中有数据可读，每次调用epoll_wait都会得到通知，可以重复通知。Epoll 默认模式</li><li>EdgeTriggered：简称ET，也叫做边沿触发。只有在某个FD有状态变化时，调用epoll_wait才会被通知，只通知一次。</li></ul><p>总结：</p><ul><li>LT：事件通知频率较高，会有重复通知，影响性能</li><li>ET：仅通知一次，效率高。 可以基于非阻塞IO循环读取解决数据读取不完整问题</li><li>select和poll仅支持LT模式，epoll可以自由选择LT和ET两种模式</li></ul><h5 id=1236-基于-epoll-的-web-服务的基本流程>1.2.3.6 基于 epoll 的 web 服务的基本流程</h5><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/1653902845082.png data-srcset="../images/1653902845082.png, ../images/1653902845082.png 1.5x, ../images/1653902845082.png 2x" data-sizes=auto alt=../images/1653902845082.png title="基于 epoll 的 web 服务的基本流程"></p><h4 id=124-信号驱动-io>1.2.4 信号驱动 IO</h4><p>信号驱动IO是与内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/1653911776583.png data-srcset="../images/1653911776583.png, ../images/1653911776583.png 1.5x, ../images/1653911776583.png 2x" data-sizes=auto alt=../images/1653911776583.png title="信号驱动 IO"></p><p>当有大量IO操作时，信号较多，SIGIO处理函数不能及时处理可能导致信号队列溢出，而且内核空间与用户空间的频繁信号交互性能也较低。</p><h4 id=125-异步-io>1.2.5 异步 IO</h4><p>这种方式，不仅仅是用户态在试图读取数据后，不阻塞，而且当内核的数据准备完成后，也不会阻塞。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/1653911877542.png data-srcset="../images/1653911877542.png, ../images/1653911877542.png 1.5x, ../images/1653911877542.png 2x" data-sizes=auto alt=../images/1653911877542.png title="异步 IO"></p><h4 id=126-五种-io-模型对比>1.2.6 五种 IO 模型对比</h4><p>同步还是异步关键看内核空间和用户空间的拷贝过程，也就是阶段二是同步还是异步。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/1653912219712.png data-srcset="../images/1653912219712.png, ../images/1653912219712.png 1.5x, ../images/1653912219712.png 2x" data-sizes=auto alt=../images/1653912219712.png title="五种 IO 模型对比"></p><h2 id=2-redis-网络模型>2. Redis 网络模型</h2><h3 id=21-redis是单线程的吗为什么使用单线程>2.1 Redis是单线程的吗？为什么使用单线程</h3><p><strong>Redis到底是单线程还是多线程？</strong></p><ul><li>如果仅仅聊Redis的核心业务部分（命令处理），答案是单线程</li><li>如果是聊整个Redis，那么答案就是多线程</li></ul><p>在Redis版本迭代过程中，在两个重要的时间节点上引入了多线程的支持：</p><ul><li>Redis v4.0：引入多线程异步处理一些耗时较旧的任务，例如异步删除命令unlink</li><li>Redis v6.0：在核心网络模型中引入 多线程，进一步提高对于多核CPU的利用率</li></ul><p>对于Redis的核心网络模型，在Redis 6.0之前确实都是单线程。是利用epoll（Linux系统）这样的IO多路复用技术在事件循环中不断处理客户端情况。</p><p><strong>为什么Redis要选择单线程？</strong></p><ul><li>抛开持久化不谈，Redis是纯 内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升。</li><li>多线程会导致过多的上下文切换，带来不必要的开销</li><li>引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣</li></ul><h3 id=22-单线程和多线程模型>2.2 单线程和多线程模型</h3><p>单线程：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/20220807144942.png data-srcset="../images/20220807144942.png, ../images/20220807144942.png 1.5x, ../images/20220807144942.png 2x" data-sizes=auto alt=../images/20220807144942.png title="Redis 单线程网络模型"></p><p>多线程：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/20220807145010.png data-srcset="../images/20220807145010.png, ../images/20220807145010.png 1.5x, ../images/20220807145010.png 2x" data-sizes=auto alt=../images/20220807145010.png title="Redis 多线程网络模型"></p><p>搞不懂了就看看<a href="https://www.bilibili.com/video/BV1cr4y1671t?p=171" target=_blank rel="external nofollow noopener noreferrer">视频教程</a></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="2022-08-07 14:00:00">更新于 2022-08-07</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/notes/databases/redis/itheima_redis_lesson/advanced/4-redis-principle-2-network/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://dilless.github.io/posts/notes/databases/redis/itheima_redis_lesson/advanced/4-redis-principle-2-network/ data-title="高级篇（四）Redis 原理篇（二）网络模型" data-hashtags=redis,数据库,缓存,实现原理,网络模型><i class="fa-brands fa-twitter fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://dilless.github.io/posts/notes/databases/redis/itheima_redis_lesson/advanced/4-redis-principle-2-network/ data-hashtag=redis><i class="fa-brands fa-facebook-square fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 WhatsApp" data-sharer=whatsapp data-url=https://dilless.github.io/posts/notes/databases/redis/itheima_redis_lesson/advanced/4-redis-principle-2-network/ data-title="高级篇（四）Redis 原理篇（二）网络模型" data-web><i class="fa-brands fa-whatsapp fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://dilless.github.io/posts/notes/databases/redis/itheima_redis_lesson/advanced/4-redis-principle-2-network/ data-title="高级篇（四）Redis 原理篇（二）网络模型"><i data-svg-src=/lib/simple-icons/icons/line.min.svg></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://dilless.github.io/posts/notes/databases/redis/itheima_redis_lesson/advanced/4-redis-principle-2-network/ data-title="高级篇（四）Redis 原理篇（二）网络模型"><i class="fa-brands fa-weibo fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Myspace" data-sharer=myspace data-url=https://dilless.github.io/posts/notes/databases/redis/itheima_redis_lesson/advanced/4-redis-principle-2-network/ data-title="高级篇（四）Redis 原理篇（二）网络模型" data-description><i data-svg-src=/lib/simple-icons/icons/myspace.min.svg></i></a>
<a href=javascript:void(0); title="分享到 Blogger" data-sharer=blogger data-url=https://dilless.github.io/posts/notes/databases/redis/itheima_redis_lesson/advanced/4-redis-principle-2-network/ data-title="高级篇（四）Redis 原理篇（二）网络模型" data-description><i class="fa-brands fa-blogger fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Evernote" data-sharer=evernote data-url=https://dilless.github.io/posts/notes/databases/redis/itheima_redis_lesson/advanced/4-redis-principle-2-network/ data-title="高级篇（四）Redis 原理篇（二）网络模型"><i class="fa-brands fa-evernote fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw"></i>&nbsp;<a href=/tags/redis/>redis</a>,&nbsp;<a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>,&nbsp;<a href=/tags/%E7%BC%93%E5%AD%98/>缓存</a>,&nbsp;<a href=/tags/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/>实现原理</a>,&nbsp;<a href=/tags/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/>网络模型</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/notes/databases/redis/itheima_redis_lesson/advanced/3-redis-principle-1-data-structure/ class=prev rel=prev title="高级篇（三）Redis 原理篇（一）数据结构"><i class="fa-solid fa-angle-left fa-fw"></i>高级篇（三）Redis 原理篇（一）数据结构</a>
<a href=/posts/notes/databases/redis/itheima_redis_lesson/advanced/5-redis-principle-3-resp-protocol/ class=next rel=next title="高级篇（五）Redis 原理篇（三）通信协议">高级篇（五）Redis 原理篇（三）通信协议<i class="fa-solid fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=giscus><script src=https://giscus.app/client.js data-repo=dilless/dilless.github.io data-repo-id=R_kgDOHr9Jag data-category=Announcements data-category-id=DIC_kwDOHr9Jas4CQ396 data-mapping=title data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.101.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel="external nofollow noopener noreferrer" title="FixIt v0.2.16-RC"><img class=fixit-icon src=/images/fixit.svg alt="FixIt logo">&nbsp;FixIt</a></div><div class="footer-line copyright"><i class="fa-regular fa-copyright fa-fw"></i>
<span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>
<a href=https://dilless.github.io target=_blank rel="external nofollow noopener noreferrer">黄波</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"></div><div class="footer-line ibruce"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw"></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa fa-spinner fa-spin fa-fw"></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw"></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa fa-spinner fa-spin fa-fw"></i></span></span></div></div></footer></div><div class=widgets><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fa-solid fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fa-solid fa-comment fa-fw"></i></a></div><a href=https://github.com/dilless title="在 GitHub 上找到我" target=_blank rel="external nofollow noopener noreferrer" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/katex/copy-tex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js defer></script><script type=text/javascript src=/lib/lunr/lunr.min.js defer></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.js defer></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.js defer></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js async defer></script><script type=text/javascript src=/lib/sharer/sharer.min.js async defer></script><script type=text/javascript src=/lib/katex/katex.min.js defer></script><script type=text/javascript src=/lib/katex/auto-render.min.js defer></script><script type=text/javascript src=/lib/katex/copy-tex.min.js defer></script><script type=text/javascript src=/lib/katex/mhchem.min.js defer></script><script type=text/javascript src=/lib/cookieconsent/cookieconsent.min.js defer></script><script type=text/javascript src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:10},comment:{giscus:{darkTheme:"dark",lightTheme:"light"}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.js defer></script><script type=text/javascript src=/js/_custom.min.js defer></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y7BJE11JP4",{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-Y7BJE11JP4" async></script></body></html>