<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>高级篇（一）Redis 分布式缓存 - 黄波的博客</title><meta name=author content="黄波"><meta name=author-link content="https://dilless.github.io"><meta name=description content="单机的Redis存在四大问题: 数据丢失问题：redis 持久化 并发能力问题：主从集群，读写分离 储存能力问题：分配集群，插槽机制动态扩容 故障恢复"><meta name=keywords content="redis,数据库,缓存,分布式,集群"><meta itemprop=name content="高级篇（一）Redis 分布式缓存"><meta itemprop=description content="单机的Redis存在四大问题: 数据丢失问题：redis 持久化 并发能力问题：主从集群，读写分离 储存能力问题：分配集群，插槽机制动态扩容 故障恢复"><meta itemprop=datePublished content="2022-07-29T00:00:00+08:00"><meta itemprop=dateModified content="2022-07-30T21:16:00+08:00"><meta itemprop=wordCount content="2909"><meta itemprop=image content="https://dilless.github.io/apple-touch-icon.png"><meta itemprop=keywords content="redis,数据库,缓存,分布式,集群,"><meta property="og:title" content="高级篇（一）Redis 分布式缓存"><meta property="og:description" content="单机的Redis存在四大问题: 数据丢失问题：redis 持久化 并发能力问题：主从集群，读写分离 储存能力问题：分配集群，插槽机制动态扩容 故障恢复"><meta property="og:type" content="article"><meta property="og:url" content="https://dilless.github.io/posts/notes/databases/redis/itheima_redis_lesson/advanced/1-redis-distribute-cache/"><meta property="og:image" content="https://dilless.github.io/apple-touch-icon.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-29T00:00:00+08:00"><meta property="article:modified_time" content="2022-07-30T21:16:00+08:00"><meta property="og:site_name" content="黄波的博客"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dilless.github.io/apple-touch-icon.png"><meta name=twitter:title content="高级篇（一）Redis 分布式缓存"><meta name=twitter:description content="单机的Redis存在四大问题: 数据丢失问题：redis 持久化 并发能力问题：主从集群，读写分离 储存能力问题：分配集群，插槽机制动态扩容 故障恢复"><meta name=application-name content="黄波的博客"><meta name=apple-mobile-web-app-title content="黄波的博客"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#252627"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://dilless.github.io/posts/notes/databases/redis/itheima_redis_lesson/advanced/1-redis-distribute-cache/><link rel=next href=https://dilless.github.io/posts/notes/databases/redis/itheima_redis_lesson/advanced/2-redis-best-practice/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><meta name=google-site-verification content="3_Zf27e0mNtTIsBWn36hi_d4KTxPd2Zh1dsZMVnKK8k"><meta name=baidu-site-verification content="code-VsfDko5mls"><meta name=360-site-verification content="1a8490494ad7f3fe3e0f7e4a61ce0775"><meta name=sogou_site_verification content="X0yE1Xexzf"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"高级篇（一）Redis 分布式缓存","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/dilless.github.io\/posts\/notes\/databases\/redis\/itheima_redis_lesson\/advanced\/1-redis-distribute-cache\/"},"genre":"posts","keywords":"redis, 数据库, 缓存, 分布式, 集群","wordcount":2909,"url":"https:\/\/dilless.github.io\/posts\/notes\/databases\/redis\/itheima_redis_lesson\/advanced\/1-redis-distribute-cache\/","datePublished":"2022-07-29T00:00:00+08:00","dateModified":"2022-07-30T21:16:00+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"黄波"},"description":""}</script></head><body header-desktop=sticky header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper github-corner=right><div class=header-title><a href=/ title=黄波的博客><img class="lazyload logo" src=/svg/loading.min.svg data-src=/apple-touch-icon.png data-srcset="/apple-touch-icon.png, /apple-touch-icon.png 1.5x, /apple-touch-icon.png 2x" data-sizes=auto alt=黄波的博客 title=黄波的博客><span class=header-title-text>黄波的博客</span></a><span class=header-subtitle>开发、学习、生活、技术分享</span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/><i class='fa-solid fa-archive fa-fw fa-sm'></i> 文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class='fa-solid fa-th fa-fw fa-sm'></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class='fa-solid fa-tags fa-fw fa-sm'></i> 标签</a></li><li class=menu-item><a class=menu-link href=/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><i class='fa-solid fa-book fa-fw fa-sm'></i> 学习笔记</a></li><li class=menu-item><a class=menu-link href=/about/><i class='fa-solid fa-info-circle fa-fw fa-sm'></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item language"><span title=选择语言>简体中文<i class="dropdown-icon fa-solid fa-chevron-down"></i></span><ul class=sub-menu><li class=menu-item>没有更多翻译</li></ul></li><li class="menu-item search" id=search-desktop><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li></ul></nav></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=黄波的博客><img class="lazyload logo" src=/svg/loading.min.svg data-src=/apple-touch-icon.png data-srcset="/apple-touch-icon.png, /apple-touch-icon.png 1.5x, /apple-touch-icon.png 2x" data-sizes=auto alt=/apple-touch-icon.png title=/apple-touch-icon.png><span class=header-title-text>黄波的博客</span></a><span class=header-subtitle>开发、学习、生活、技术分享</span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/posts/><i class='fa-solid fa-archive fa-fw fa-sm'></i> 文章</a></li><li class=menu-item><a class=menu-link href=/categories/><i class='fa-solid fa-th fa-fw fa-sm'></i> 分类</a></li><li class=menu-item><a class=menu-link href=/tags/><i class='fa-solid fa-tags fa-fw fa-sm'></i> 标签</a></li><li class=menu-item><a class=menu-link href=/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><i class='fa-solid fa-book fa-fw fa-sm'></i> 学习笔记</a></li><li class=menu-item><a class=menu-link href=/about/><i class='fa-solid fa-info-circle fa-fw fa-sm'></i> 关于</a></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li><li class="menu-item language"><span title=选择语言>简体中文<i class="dropdown-icon fa-solid fa-chevron-down"></i></span>
<select class=language-select onchange="location=this.value"><option disabled>没有更多翻译</option></select></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container page-style=normal><aside class=toc id=toc-auto><h2 class=toc-title>目录 <i class="toc-icon fa-solid fa-angle-down fa-fw"></i></h2><div class=toc-content id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>高级篇（一）Redis 分布式缓存</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://dilless.github.io title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><i class="fa-solid fa-user-circle"></i>
黄波</a></span>
<span class=post-category>收录于 <a href=/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/><i class="fa-regular fa-folder fa-fw"></i>&nbsp;学习笔记</a>&ensp;<a href=/categories/redis/><i class="fa-regular fa-folder fa-fw"></i>&nbsp;redis</a></span></div><div class=post-meta-line><span title="2022-07-29 00:00:00"><i class="fa-regular fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-07-29>2022-07-29</time>
</span>&nbsp;<i class="fa-solid fa-pencil-alt fa-fw"></i>&nbsp;约 2909 字&nbsp;
<i class="fa-regular fa-clock fa-fw"></i>&nbsp;预计阅读 6 分钟&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title="高级篇（一）Redis 分布式缓存">
<i class="fa-regular fa-eye fa-fw"></i>&nbsp;<span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-redis-持久化>1. Redis 持久化</a><ul><li><a href=#11-rdb-redis-database-backup-file>1.1 RDB （Redis Database Backup file）</a><ul><li><a href=#111-执行时机>1.1.1 执行时机</a></li><li><a href=#112-rdb-原理>1.1.2 RDB 原理</a></li><li><a href=#113-总结>1.1.3 总结</a></li></ul></li><li><a href=#12-aof-append-only-file>1.2 AOF (Append Only File)</a><ul><li><a href=#121-aof-原理>1.2.1 AOF 原理</a></li><li><a href=#122-aof-配置>1.2.2 AOF 配置</a></li><li><a href=#123-aof-文件重写>1.2.3 AOF 文件重写</a></li></ul></li><li><a href=#13-rdb-vs-aof>1.3 RDB vs AOF</a></li></ul></li><li><a href=#2-redis-主从>2. Redis 主从</a><ul><li><a href=#22-主从同步原理>2.2 主从同步原理</a><ul><li><a href=#221-全量同步>2.2.1 全量同步</a></li><li><a href=#222-增量同步>2.2.2 增量同步</a></li><li><a href=#224-repl_backlog-原理>2.2.4 repl_backlog 原理</a></li></ul></li><li><a href=#23-主从同步优化>2.3 主从同步优化</a></li><li><a href=#24-小结>2.4 小结</a></li></ul></li><li><a href=#3-redis-哨兵>3. Redis 哨兵</a><ul><li><a href=#31-哨兵原理>3.1 哨兵原理</a><ul><li><a href=#311-集群结构和作用>3.1.1 集群结构和作用</a></li><li><a href=#312-集群监控原理>3.1.2 集群监控原理</a></li><li><a href=#313-集群故障恢复原理>3.1.3 集群故障恢复原理</a></li><li><a href=#314小结>3.1.4.小结</a></li></ul></li><li><a href=#32-搭建哨兵集群>3.2 搭建哨兵集群</a></li><li><a href=#33-redis-py-使用哨兵集群>3.3 redis-py 使用哨兵集群</a></li></ul></li><li><a href=#4-redis-分片集群>4. Redis 分片集群</a><ul><li><a href=#41-搭建分片集群>4.1 搭建分片集群</a></li><li><a href=#42-散列插槽>4.2 散列插槽</a><ul><li><a href=#421-小结>4.2.1 小结</a></li></ul></li><li><a href=#43-集群伸缩>4.3 集群伸缩</a><ul><li><a href=#433-添加新节点到redis>4.3.3 添加新节点到redis</a></li><li><a href=#434-转移插槽>4.3.4 转移插槽</a></li></ul></li><li><a href=#44-故障转移>4.4 故障转移</a><ul><li><a href=#441-自动故障转移>4.4.1 自动故障转移</a></li><li><a href=#442-手动故障转移>4.4.2 手动故障转移</a></li></ul></li><li><a href=#45-redis-py-使用分片集群>4.5 redis-py 使用分片集群</a></li></ul></li></ul></nav></div></div><div class=content id=content><p>单机的Redis存在四大问题:</p><ol><li>数据丢失问题：redis 持久化</li><li>并发能力问题：主从集群，读写分离</li><li>储存能力问题：分配集群，插槽机制动态扩容</li><li>故障恢复问题：redis 哨兵，健康检测和自动恢复</li></ol><h2 id=1-redis-持久化>1. Redis 持久化</h2><h3 id=11-rdb-redis-database-backup-file>1.1 RDB （Redis Database Backup file）</h3><p>Redis数据快照，把内存中的所有数据都记录到磁盘中。</p><h4 id=111-执行时机>1.1.1 执行时机</h4><ul><li>执行 save 命令：主进程执行，会阻塞所有命令</li><li>执行 bgsave 命令：开启子进程执行</li><li>Redis 停机时</li><li>触发 RDB 条件时：redis.conf 中配置，如 <code>save 900 1</code> 表示 900 秒内至少一个 key 被修改，则执行 <code>bgsave</code></li></ul><h4 id=112-rdb-原理>1.1.2 RDB 原理</h4><p>fork采用的是copy-on-write技术：</p><ul><li>当主进程执行读操作时，访问共享内存</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作</li><li>极端情况内存占用翻倍</li></ul><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/image-20210725151319695.png data-srcset="../images/image-20210725151319695.png, ../images/image-20210725151319695.png 1.5x, ../images/image-20210725151319695.png 2x" data-sizes=auto alt=../images/image-20210725151319695.png title="rdb 原理"></p><h4 id=113-总结>1.1.3 总结</h4><ul><li>RDB 基本流程：fork (共享内存空间) -> 子进程读内存写入新 RDB 文件 -> 替换旧 RDB 文件</li><li><code>save 60 1000</code> 的含义？</li><li>RDB 缺点：<ul><li>数据丢失风险</li><li>耗时长</li></ul></li></ul><h3 id=12-aof-append-only-file>1.2 AOF (Append Only File)</h3><h4 id=121-aof-原理>1.2.1 AOF 原理</h4><p>AOF 记录写命令，可以看作命令日志，恢复时把记录的命令执行一遍</p><h4 id=122-aof-配置>1.2.2 AOF 配置</h4><ul><li>默认关闭</li><li>记录频率配置<ul><li><code>appendfsync always</code>：立即记录</li><li><code>appendfsync everysec</code>：每秒记录一次(<strong>默认</strong>)</li><li><code>appendfsync no</code>：由操作系统 fsync</li></ul></li></ul><h4 id=123-aof-文件重写>1.2.3 AOF 文件重写</h4><p>AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行 <code>bgrewriteaof</code> 命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><ul><li><code>bgrewriteaof</code></li><li>也可以在 redis.conf 中配置阈值触发</li></ul><h3 id=13-rdb-vs-aof>1.3 RDB vs AOF</h3><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/image-20210725151940515.png data-srcset="../images/image-20210725151940515.png, ../images/image-20210725151940515.png 1.5x, ../images/image-20210725151940515.png 2x" data-sizes=auto alt=../images/image-20210725151940515.png title="RDB vs AOF"></p><h2 id=2-redis-主从>2. Redis 主从</h2><p>命令或配置文件创建主从关系：<code>{slaveof | replicaof} &lt;masterip> &lt;masterport></code></p><h3 id=22-主从同步原理>2.2 主从同步原理</h3><h4 id=221-全量同步>2.2.1 全量同步</h4><p>主从第一次建立连接时，会执行<strong>全量同步</strong></p><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/image-20210725152222497.png data-srcset="../images/image-20210725152222497.png, ../images/image-20210725152222497.png 1.5x, ../images/image-20210725152222497.png 2x" data-sizes=auto alt=../images/image-20210725152222497.png title=全量同步></p><p>master如何得知salve是第一次来连接呢？？</p><p>有几个概念，可以作为判断依据(版本信息)：</p><ul><li><strong>Replication Id</strong>：简称 replid，是数据集的标记，id一致则说明是同一数据集。每一个 master 都有唯一的 replid，slave 则会继承
master 节点的 replid</li><li><strong>offset</strong>：偏移量，随着记录在 repl_backlog 中的数据增多而逐渐增大。slave 完成同步时也会记录当前同步的 offset。如果 slave
的 offset小于 master 的 offset，说明 slave 数据落后于 master，需要更新。</li></ul><p>因此slave做数据同步，必须向 master 声明自己的 replication id 和 offset，master 才可以判断到底需要同步哪些数据。</p><p><strong>master判断一个节点是否是第一次同步的依据，就是看replid是否一致</strong>。</p><h4 id=222-增量同步>2.2.2 增量同步</h4><p>如果 slave 重启，执行增量同步</p><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/image-20210725153201086.png data-srcset="../images/image-20210725153201086.png, ../images/image-20210725153201086.png 1.5x, ../images/image-20210725153201086.png 2x" data-sizes=auto alt=../images/image-20210725153201086.png title=增量同步></p><h4 id=224-repl_backlog-原理>2.2.4 repl_backlog 原理</h4><p>这个文件是一个固定大小的数组，只不过数组是环形，也就是说<strong>角标到达数组末尾后，会再次从0开始读写</strong>，这样数组头部的数据就会被覆盖。</p><p>直到数组被填满，会覆盖旧数据，如果覆盖的是已同步的数据，没有影响；但如果被覆盖的是未同步的数据，那只能做<strong>全量同步</strong>了。</p><h3 id=23-主从同步优化>2.3 主从同步优化</h3><ul><li>在master中配置 <code>repl-diskless-sync yes</code> 启用无磁盘复制，避免全量同步时的磁盘IO。</li><li>Redis 单节点上的内存占用不要太大，减少 RDB 导致的过多磁盘 IO</li><li>适当提高 repl_backlog 的大小，发现 slave 宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个 master 上的 slave 节点数量，如果实在是太多 slave，则可以采用主-从-从链式结构，减少 master 压力</li></ul><h3 id=24-小结>2.4 小结</h3><p>简述全量同步和增量同步区别？</p><ul><li>全量同步：master 将完整内存数据生成 RDB，发送 RDB 到 slave。后续命令则记录在 repl_backlog，逐个发送给 slave。</li><li>增量同步：slave 提交自己的 offset 到 master，master 获取 repl_backlog 中从 offset 之后的命令给 slave</li></ul><p>什么时候执行全量同步？</p><ul><li>slave 节点第一次连接 master 节点时</li><li>slave 节点断开时间太久，repl_backlog 中的 offset 已经被覆盖时</li></ul><p>什么时候执行增量同步？</p><ul><li>slave 节点断开又恢复，并且在 repl_backlog 中能找到 offset 时</li></ul><h2 id=3-redis-哨兵>3. Redis 哨兵</h2><h3 id=31-哨兵原理>3.1 哨兵原理</h3><h4 id=311-集群结构和作用>3.1.1 集群结构和作用</h4><p>结构：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/image-20210725154528072.png data-srcset="../images/image-20210725154528072.png, ../images/image-20210725154528072.png 1.5x, ../images/image-20210725154528072.png 2x" data-sizes=auto alt=../images/image-20210725154528072.png title=哨兵结构></p><p>作用：</p><ul><li>监控</li><li>自动故障恢复：将一个 slave 提升为 master， 故障实力恢复后也以新 master 为主</li><li>通知：Sentinel 充当 Redis 客户端的服务发现来源，故障结构变化后，会通知客户端(谁是 master，谁是 slave)</li></ul><h4 id=312-集群监控原理>3.1.2 集群监控原理</h4><p>Sentinel 基于心跳机制，每秒发个 ping 命令：</p><ul><li>主观下线：某个 Sentinel 发现某个实例超时未响应</li><li>客观下线(实际判定为故障节点)：超过指定数量的 Sentinel 都认为该实例主观下线</li></ul><h4 id=313-集群故障恢复原理>3.1.3 集群故障恢复原理</h4><p>选举新的 master：</p><ul><li>判断 slave 于 master 断开时间长短，超过指定值则排除该 slave</li><li>判断 slave 的 slave-priority，越小越优先</li><li>如果 slave-priority 一样，则判断 slave 的 offset，越新越优先</li><li>随便挑一个(id 越小越优先)</li></ul><p>实现故障转移</p><ul><li>向 slave 发送 <code>slaveof no one</code> 命令，让该节点成为 master</li><li>Sentinel 让其他所有 slave 发送 <code>slaveof &lt;ip> &lt;port></code>，使其成为新 master 的 slave</li><li>将故障节点标记为 slave，故障恢复后自动成为新 master 的 slave</li></ul><h4 id=314小结>3.1.4.小结</h4><p>Sentinel的三个作用是什么？</p><ul><li>监控</li><li>故障转移</li><li>通知</li></ul><p>Sentinel 如何判断一个 redis 实例是否健康？</p><ul><li>每隔1秒发送一次 ping 命令，如果超过一定时间没有相向则认为是主观下线</li><li>如果大多数 sentinel 都认为实例主观下线，则判定服务下线</li></ul><p>故障转移步骤有哪些？</p><ul><li>首先选定一个slave作为新的master，执行 slaveof no one</li><li>然后让所有节点都执行 slaveof 新master</li><li>修改故障节点配置，添加 slaveof 新master</li></ul><h3 id=32-搭建哨兵集群>3.2 搭建哨兵集群</h3><p>配置哨兵:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># sentinel.conf
</span></span><span class=line><span class=cl>port 27001
</span></span><span class=line><span class=cl>sentinel announce-ip 192.168.31.57
</span></span><span class=line><span class=cl>sentinel monitor mymaster 192.168.31.57 7001 2
</span></span><span class=line><span class=cl>sentinel down-after-milliseconds mymaster 5000
</span></span><span class=line><span class=cl>sentinel failover-timeout mymaster 60000
</span></span><span class=line><span class=cl>dir &#34;/tmp/s1&#34;
</span></span></code></pre></td></tr></table></div></div><p>启动：<code>redis-sentinel s1/sentinel.conf</code></p><h3 id=33-redis-py-使用哨兵集群>3.3 redis-py 使用哨兵集群</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>sentinel</span> <span class=o>=</span> <span class=n>redis</span><span class=o>.</span><span class=n>sentinel</span><span class=o>.</span><span class=n>Sentinel</span><span class=p>([(</span><span class=s1>&#39;192.168.31.57&#39;</span><span class=p>,</span> <span class=mi>27001</span><span class=p>),</span> <span class=p>(</span><span class=s1>&#39;192.168.31.57&#39;</span><span class=p>,</span> <span class=mi>27002</span><span class=p>),</span> <span class=p>(</span><span class=s1>&#39;192.168.31.57&#39;</span><span class=p>,</span> <span class=mi>27003</span><span class=p>)])</span>
</span></span><span class=line><span class=cl><span class=n>master</span> <span class=o>=</span> <span class=n>sentinel</span><span class=o>.</span><span class=n>master_for</span><span class=p>(</span><span class=s1>&#39;mymaster&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>master</span><span class=o>.</span><span class=n>set</span><span class=p>(</span><span class=s1>&#39;foo&#39;</span><span class=p>,</span> <span class=s1>&#39;bar&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>slave</span> <span class=o>=</span> <span class=n>sentinel</span><span class=o>.</span><span class=n>slave_for</span><span class=p>(</span><span class=s1>&#39;mymaster&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>resp</span> <span class=o>=</span> <span class=n>slave</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;foo&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>resp</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=4-redis-分片集群>4. Redis 分片集群</h2><h3 id=41-搭建分片集群>4.1 搭建分片集群</h3><p>分配集群解决的问题(主从、哨兵无法解决):</p><ul><li>海量数据存储</li><li>高并发写</li></ul><p>分片集群特征：</p><ul><li>集群中有多个 master，每个 master 保存不同数据</li><li>每个 master 都可以有多个 slave 节点</li><li>master 之间通过 ping 监测彼此健康状态</li><li>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</li></ul><p>创建：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>redis-cli --cluster create --cluster-replicas <span class=m>1</span> 192.168.31.57:7001 192.168.31.57:7002 192.168.31.57:7003 192.168.31.57:8001 192.168.31.57:8002 192.168.31.57:8003
</span></span></code></pre></td></tr></table></div></div><p><code>--replicas 1</code>或者<code>--cluster-replicas 1</code> ：指定集群中每个master的副本个数为1，此时<code>节点总数 ÷ (replicas + 1)</code> 得到的就是master的数量。因此节点列表中的前n个就是master，其它节点都是slave节点，随机分配到不同master</p><p>查看：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>redis-cli -p <span class=m>7001</span> cluster nodes
</span></span></code></pre></td></tr></table></div></div><p>连接集群：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>redis-cli -c -p <span class=m>7001</span>
</span></span><span class=line><span class=cl><span class=c1># -c  Enable cluster mode (follow -ASK and -MOVED redirections).</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=42-散列插槽>4.2 散列插槽</h3><p>Redis 会把每一个 master 节点映射到 0~16383 共 16384 个插槽（hash slot）上。</p><p><strong>数据 key 不是与节点绑定，而是与插槽绑定。</strong></p><p>redis 会根据 key 的有效部分计算插槽值，分两种情况：</p><ul><li>key 中包含"{}"，且“{}”中至少包含1个字符，“{}”中的部分是有效部分</li><li>key 中不包含“{}”，整个key都是有效部分</li></ul><p>计算方式：利用 CRC16 算法得到一个 hash 值，然后对 16384 取余，得到的结果就是 slot 值。</p><h4 id=421-小结>4.2.1 小结</h4><p>Redis 如何判断某个key应该在哪个实例？</p><ul><li>将 16384 个插槽分配到不同的实例</li><li>根据 key 的有效部分计算哈希值，对 16384 取余</li><li>余数作为插槽，寻找插槽所在实例即可</li></ul><p>如何将同一类数据固定的保存在同一个Redis实例？</p><ul><li>这一类数据使用相同的有效部分，例如 key 都以 {typeId} 为前缀</li></ul><h3 id=43-集群伸缩>4.3 集群伸缩</h3><h4 id=433-添加新节点到redis>4.3.3 添加新节点到redis</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>redis-cli --cluster add-node
</span></span></code></pre></td></tr></table></div></div><h4 id=434-转移插槽>4.3.4 转移插槽</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>redis-cli --cluster reshard
</span></span></code></pre></td></tr></table></div></div><h3 id=44-故障转移>4.4 故障转移</h3><h4 id=441-自动故障转移>4.4.1 自动故障转移</h4><p>当分片集群中一个 master 宕机：</p><ul><li>该实例与其他实例失去连接</li><li>疑似宕机</li><li>确定下线，提升 slave 为 master</li><li>master 重新上线后成为 slave</li></ul><h4 id=442-手动故障转移>4.4.2 手动故障转移</h4><p>利用 <code>cluster failover</code> 命令可以手动让集群中的某个 master 宕机，切换到执行 <code>cluster failover</code> 命令的这个 slave 节点，实现无感知的数据迁移。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/image-20210725162441407.png data-srcset="../images/image-20210725162441407.png, ../images/image-20210725162441407.png 1.5x, ../images/image-20210725162441407.png 2x" data-sizes=auto alt=../images/image-20210725162441407.png title=手动故障转移></p><p>这种 failover 命令可以指定三种模式：</p><ul><li>缺省：默认的流程，如图 1~6 步</li><li>force：省略了对 offset 的一致性校验</li><li>takeover：直接执行第5歩，忽略数据一致性、忽略 master 状态和其它master的意见</li></ul><h3 id=45-redis-py-使用分片集群>4.5 redis-py 使用分片集群</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>nodes</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>redis</span><span class=o>.</span><span class=n>cluster</span><span class=o>.</span><span class=n>ClusterNode</span><span class=p>(</span><span class=n>host</span><span class=o>=</span><span class=s1>&#39;192.168.31.57&#39;</span><span class=p>,</span> <span class=n>port</span><span class=o>=</span><span class=mi>7001</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>redis</span><span class=o>.</span><span class=n>cluster</span><span class=o>.</span><span class=n>ClusterNode</span><span class=p>(</span><span class=n>host</span><span class=o>=</span><span class=s1>&#39;192.168.31.57&#39;</span><span class=p>,</span> <span class=n>port</span><span class=o>=</span><span class=mi>7002</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>redis</span><span class=o>.</span><span class=n>cluster</span><span class=o>.</span><span class=n>ClusterNode</span><span class=p>(</span><span class=n>host</span><span class=o>=</span><span class=s1>&#39;192.168.31.57&#39;</span><span class=p>,</span> <span class=n>port</span><span class=o>=</span><span class=mi>7003</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>redis</span><span class=o>.</span><span class=n>cluster</span><span class=o>.</span><span class=n>ClusterNode</span><span class=p>(</span><span class=n>host</span><span class=o>=</span><span class=s1>&#39;192.168.31.57&#39;</span><span class=p>,</span> <span class=n>port</span><span class=o>=</span><span class=mi>8001</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>redis</span><span class=o>.</span><span class=n>cluster</span><span class=o>.</span><span class=n>ClusterNode</span><span class=p>(</span><span class=n>host</span><span class=o>=</span><span class=s1>&#39;192.168.31.57&#39;</span><span class=p>,</span> <span class=n>port</span><span class=o>=</span><span class=mi>8002</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>redis</span><span class=o>.</span><span class=n>cluster</span><span class=o>.</span><span class=n>ClusterNode</span><span class=p>(</span><span class=n>host</span><span class=o>=</span><span class=s1>&#39;192.168.31.57&#39;</span><span class=p>,</span> <span class=n>port</span><span class=o>=</span><span class=mi>8003</span><span class=p>),</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>cluster</span> <span class=o>=</span> <span class=n>redis</span><span class=o>.</span><span class=n>cluster</span><span class=o>.</span><span class=n>RedisCluster</span><span class=p>(</span><span class=n>startup_nodes</span><span class=o>=</span><span class=n>nodes</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>cluster</span><span class=o>.</span><span class=n>set</span><span class=p>(</span><span class=s1>&#39;foo&#39;</span><span class=p>,</span> <span class=s1>&#39;bar&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>resp</span> <span class=o>=</span> <span class=n>cluster</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;foo&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>resp</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="2022-07-30 21:16:00">更新于 2022-07-30</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/notes/databases/redis/itheima_redis_lesson/advanced/1-redis-distribute-cache/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://dilless.github.io/posts/notes/databases/redis/itheima_redis_lesson/advanced/1-redis-distribute-cache/ data-title="高级篇（一）Redis 分布式缓存" data-hashtags=redis,数据库,缓存,分布式,集群><i class="fa-brands fa-twitter fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://dilless.github.io/posts/notes/databases/redis/itheima_redis_lesson/advanced/1-redis-distribute-cache/ data-hashtag=redis><i class="fa-brands fa-facebook-square fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 WhatsApp" data-sharer=whatsapp data-url=https://dilless.github.io/posts/notes/databases/redis/itheima_redis_lesson/advanced/1-redis-distribute-cache/ data-title="高级篇（一）Redis 分布式缓存" data-web><i class="fa-brands fa-whatsapp fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://dilless.github.io/posts/notes/databases/redis/itheima_redis_lesson/advanced/1-redis-distribute-cache/ data-title="高级篇（一）Redis 分布式缓存"><i data-svg-src=/lib/simple-icons/icons/line.min.svg></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://dilless.github.io/posts/notes/databases/redis/itheima_redis_lesson/advanced/1-redis-distribute-cache/ data-title="高级篇（一）Redis 分布式缓存"><i class="fa-brands fa-weibo fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Myspace" data-sharer=myspace data-url=https://dilless.github.io/posts/notes/databases/redis/itheima_redis_lesson/advanced/1-redis-distribute-cache/ data-title="高级篇（一）Redis 分布式缓存" data-description><i data-svg-src=/lib/simple-icons/icons/myspace.min.svg></i></a>
<a href=javascript:void(0); title="分享到 Blogger" data-sharer=blogger data-url=https://dilless.github.io/posts/notes/databases/redis/itheima_redis_lesson/advanced/1-redis-distribute-cache/ data-title="高级篇（一）Redis 分布式缓存" data-description><i class="fa-brands fa-blogger fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Evernote" data-sharer=evernote data-url=https://dilless.github.io/posts/notes/databases/redis/itheima_redis_lesson/advanced/1-redis-distribute-cache/ data-title="高级篇（一）Redis 分布式缓存"><i class="fa-brands fa-evernote fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw"></i>&nbsp;<a href=/tags/redis/>redis</a>,&nbsp;<a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>,&nbsp;<a href=/tags/%E7%BC%93%E5%AD%98/>缓存</a>,&nbsp;<a href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F/>分布式</a>,&nbsp;<a href=/tags/%E9%9B%86%E7%BE%A4/>集群</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/notes/databases/redis/itheima_redis_lesson/advanced/2-redis-best-practice/ class=next rel=next title="高级篇（二）Redis 最佳实践">高级篇（二）Redis 最佳实践<i class="fa-solid fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=giscus><script src=https://giscus.app/client.js data-repo=dilless/dilless.github.io data-repo-id=R_kgDOHr9Jag data-category=Announcements data-category-id=DIC_kwDOHr9Jas4CQ396 data-mapping=title data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.102.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel="external nofollow noopener noreferrer" title="FixIt v0.2.16-RC"><img class=fixit-icon src=/images/fixit.svg alt="FixIt logo">&nbsp;FixIt</a></div><div class="footer-line copyright"><i class="fa-regular fa-copyright fa-fw"></i>
<span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>
<a href=https://dilless.github.io target=_blank rel="external nofollow noopener noreferrer">黄波</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"></div><div class="footer-line ibruce"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw"></i>&nbsp;<span id=busuanzi_value_site_uv><i class="fa fa-spinner fa-spin fa-fw"></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw"></i>&nbsp;<span id=busuanzi_value_site_pv><i class="fa fa-spinner fa-spin fa-fw"></i></span></span></div></div></footer></div><div class=widgets><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fa-solid fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fa-solid fa-comment fa-fw"></i></a></div><a href=https://github.com/dilless title="在 GitHub 上找到我" target=_blank rel="external nofollow noopener noreferrer" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/katex/copy-tex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js defer></script><script type=text/javascript src=/lib/lunr/lunr.min.js defer></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.js defer></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.js defer></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js async defer></script><script type=text/javascript src=/lib/sharer/sharer.min.js async defer></script><script type=text/javascript src=/lib/katex/katex.min.js defer></script><script type=text/javascript src=/lib/katex/auto-render.min.js defer></script><script type=text/javascript src=/lib/katex/copy-tex.min.js defer></script><script type=text/javascript src=/lib/katex/mhchem.min.js defer></script><script type=text/javascript src=/lib/cookieconsent/cookieconsent.min.js defer></script><script type=text/javascript src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js async defer></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:10},comment:{giscus:{darkTheme:"dark",lightTheme:"light"}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.js defer></script><script type=text/javascript src=/js/_custom.min.js defer></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y7BJE11JP4",{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-Y7BJE11JP4" async></script></body></html>